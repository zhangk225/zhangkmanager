// Copyright 2012 Citrix Systems, Inc. Licensed under the
// Apache License, Version 2.0 (the "License"); you may not use this
// file except in compliance with the License.  Citrix Systems, Inc.
// reserves all rights not expressly granted by the License.
// You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// 
// Automatically generated by addcopyright.py at 04/03/2012
package com.zhangkssh.baseframe.common.util;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.URL;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;
import java.util.Set;

import org.apache.log4j.Logger;

class PropertiesUtil {
	private static final Logger s_logger = Logger
			.getLogger(PropertiesUtil.class.getName());

	/**
	 * Searches the class path and local paths to find the config file.
	 * 
	 * @param path
	 *            path to find. if it starts with / then it's absolute path.
	 * @return File or null if not found at all.
	 */
	File findConfigFile(String path) {
		ClassLoader cl = PropertiesUtil.class.getClassLoader();
		URL url = cl.getResource(path);
		if (url != null) {
			return new File(url.getFile());
		}

		url = ClassLoader.getSystemResource(path);
		if (url != null) {
			return new File(url.getFile());
		}

		File file = new File(path);
		if (file.exists()) {
			return file;
		}

		String newPath = "conf" + (path.startsWith(File.separator) ? "" : "/")
				+ path;
		url = ClassLoader.getSystemResource(newPath);
		if (url != null) {
			return new File(url.getFile());
		}

		url = cl.getResource(newPath);
		if (url != null) {
			return new File(url.getFile());
		}

		newPath = "conf"
				+ (path.startsWith(File.separator) ? "" : File.separator)
				+ path;
		file = new File(newPath);
		if (file.exists()) {
			return file;
		}

		newPath = System.getenv("CATALINA_HOME");
		if (newPath == null) {
			newPath = System.getenv("CATALINA_BASE");
		}

		if (newPath == null) {
			newPath = System.getProperty("catalina.home");
		}

		if (newPath == null) {
			return null;
		}

		file = new File(newPath + File.separator + "conf" + File.separator
				+ path);
		if (file.exists()) {
			return file;
		}

		return null;
	}

	/**
	 * 得到资源文件
	 * 
	 * @return
	 */
	Properties getProperties(String fileName) throws IOException {
		InputStream inputStream = CommonUtil.class.getClassLoader()
				.getResourceAsStream(fileName);
		Properties p = new Properties();
		p.load(inputStream);
		return p;
	}

	// /**
	// * 获取资源文件的另一种方法
	// * @param propertiesName
	// * @return
	// */
	// public static Properties getProperties(String propertiesName) {
	// Properties dbpro = null;
	// try {
	// dbpro = new Properties();
	// File dbFile = PropertiesUtil.findConfigFile(propertiesName);
	//
	// String path = dbFile.getAbsolutePath().replaceAll("%20", " ");
	// File newFile = new File(path);
	// dbpro.load(new FileInputStream(newFile));
	//
	// //dbpro.load(new FileInputStream(dbFile));
	// } catch (FileNotFoundException fnfex) {
	// s_logger.error("Unable to find properites file", fnfex);
	// } catch (IOException ioex) {
	// s_logger.error("Exception loading properties file", ioex);
	// }
	// return dbpro;
	// }

	static Map<String, Object> toMap(Properties props) {
		Set<String> names = props.stringPropertyNames();
		HashMap<String, Object> map = new HashMap<String, Object>(names.size());
		for (String name : names) {
			map.put(name, props.getProperty(name));
		}
		return map;
	}

	/*
	 * Returns an InputStream for the given resource This is needed to read the
	 * files within a jar in classpath.
	 */
	static InputStream openStreamFromURL(String path) {
		ClassLoader cl = PropertiesUtil.class.getClassLoader();
		URL url = cl.getResource(path);
		if (url != null) {
			try {
				InputStream stream = url.openStream();
				return stream;
			} catch (IOException ioex) {
				return null;
			}
		}
		return null;
	}

	/**
	 * @param filePath
	 *            配置文件所在的全路径
	 * @param parameterName
	 *            数据库配置文件的key
	 * @param parameterValue
	 *            数据库配置文件要修改成为的value
	 */
	static void writeProperties(String filePath, String parameterName,
			String parameterValue) throws Exception {
		Properties prop = new Properties();
		try {
			InputStream fis = new FileInputStream(filePath);
			// 从输入流中读取属性列表（键和元素对）
			prop.load(fis);
			// 调用 Hashtable 的方法 put。使用 getProperty 方法提供并行性。
			// 强制要求为属性的键和值使用字符串。返回值是 Hashtable 调用 put 的结果。
			OutputStream fos = new FileOutputStream(filePath);
			if (parameterValue.contains(":") || parameterValue.contains("=")) {
				prop.remove(parameterName);
			} else {
				prop.setProperty(parameterName, parameterValue);
			}
			// 以适合使用 load 方法加载到 Properties 表中的格式，
			// 将此 Properties 表中的属性列表（键和元素对）写入输出流
			prop.store(fos, "Update '" + parameterName + "' value");
			if (parameterValue.contains(":") || parameterValue.contains("=")) {
				String str = parameterName + "=" + parameterValue;
				writeFile(filePath, str);
			}
		} catch (IOException e) {
			s_logger.error("write properties failed", e);
			throw new Exception("write properties failed");
		}
	}

	/**
	 * 写文件
	 * 
	 * @param path
	 * @param filename
	 * @return
	 */
	static boolean writeFile(String path, String str) {
		File file = new File(path);
		FileWriter fw;
		try {
			fw = new FileWriter(file, true); // 此项为true是关键,若不填,评测将会用一空白文件覆盖原件
			fw.write(str);
			fw.close();
		} catch (IOException e) {
			return false;
		}
		return true;
	}

}
